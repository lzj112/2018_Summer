张逸，曾先后就职于中兴通讯、惠普 GDCC、中软国际、ThoughtWorks 等大型中外企业，任职角色为高级软件工程师、架构师、技术总监、首席咨询师。GitChat 畅销精品课作者。 

精通包括 Java、Scala、Python、C#、JavaScript、Ruby 等多种语言，熟练掌握面向对象思想、测试驱动开发与重构、领域驱动设计、函数式编程、架构、大数据分析、敏捷与过程改进，并致力于大型软件企业的面向服务系统架构设计、大数据平台架构设计以及互联网 Web 系统架构设计。 

著译作包括《软件设计精要与模式》、《Java 设计模式》、《恰如其分的软件架构》、《WCF 服务编程》、《人件》、《重构——改善既有代码设计》评注版、以及《架构之美（Beatiful Architecture）》评注版。 

版权声明 
本文及文中所涉及课程均为 GitChat 平台独家发布，未经授权不得转载。
分层架构是运用最为广泛的架构模式，几乎每个软件系统都需要通过层（Layer）来隔离不同的关注点（Concern Point），以此应对不同需求的变化，使得这种变化可以独立进行；此外，分层架构模式还是隔离业务复杂度与技术复杂度的利器，《领域驱动设计模式、原理与实践》写道：

为了避免将代码库变成大泥球（BBoM）并因此减弱领域模型的完整性且最终减弱可用性，系统架构要支持技术复杂性与领域复杂性的分离。引起技术实现发生变化的原因与引起领域逻辑发生变化的原因显然不同，这就导致基础设施和领域逻辑问题会以不同速率发生变化。

这里所谓的“以不同速率发生变化”，其实就是引起变化的原因各有不同，这正好是单一职责原则（Single-Responsibility Principle，SRP）的体现。Robert Martin 认为单一职责原则就是“一个类应该只有一个引起它变化的原因”，换言之，如果有两个引起类变化的原因，就需要分离。单一职责原则可以理解为架构原则，这时要考虑的就不是类，而是层次。我们为什么要将业务与基础设施分开？正是因为引起它们变化的原因不同。

经典分层架构
分层架构由来已久，将一个软件系统进行分层，似乎已经成为了每个开发人员的固有意识，甚至不必思考即可自然得出。这其中最为经典的就是三层架构以及领域驱动设计提出的四层架构。

经典三层架构

在软件架构中，经典三层架构自顶向下由用户界面层（User Interface Layer）、业务逻辑层（Business Logic Layer）与数据访问层（Data Access Layer）组成。该分层架构之所以能够流行，是有其历史原因的。在提出该分层架构的时代，多数企业系统往往较为简单，本质上都是一个单体架构（Monolithic Architecture）的数据库管理系统。这种分层架构已经是Client-Server架构的进化了，它有效地隔离了业务逻辑与数据访问逻辑，使得这两个不同关注点能够相对自由和独立地演化。一个经典的三层架构如下所示： 

域驱动设计的经典分层架构

领域驱动设计在经典三层架构的基础上做了进一步改良，在用户界面层与业务逻辑层之间引入了新的一层，即应用层（Application Layer）。同时，一些层次的命名也发生了变化。将业务逻辑层更名为领域层自然是题中应有之义，而将数据访问层更名为基础设施层（Infrastructure Layer），则突破了之前数据库管理系统的限制，扩大了这个负责封装技术复杂度的基础层次的内涵。下图为 Eric Evans 在其经典著作《领域驱动设计》中的分层架构：
追溯分层架构的本源

赵实际上就是 ----“管理一个任务队列，一个线程队列，然后让每一个 thread 都去执行调度函数：循环获取一个 task，然后执行之。
每一个线程执行调度函数 : 每个线程循环取任务(应是封装在任务队列的函数),失败即阻塞,取到了就执行任务函数
需要实现的就是 任务队列 :　std::vector<TASK> task;
      线程池　：std::vector<std::thread> t  
一个任务队列了类 一个线程池类,线程池包含任务队列

--------------------------------------------------------------------------------

c++中使用pthread_create()函数时，该函数的第三个参数必须指向一个静态函数。而要在一个静态函数中使用类的动态成员（包括成员函数和成员变量）则只能：
1】通过类的静态对象来调用。比如单体模式中，静态函数可以通过类的全局唯一实例来访问动态成员函数
2】将类的对象作为参数传递给该静态函数，然后在静态函数中应用这个对象，并调用其动态方法

--------------------------------------------------------------------------------

线程池一般需要具备下面几个组成部分：
1 】 线程池管理器：用于创建并管理线程；
2 】工作线程：线程池中实际执行的线程
3 】任务接口：尽管线程池大多数情况下是用来支持网络服务器，但是我们将线程执行的任务抽象出来，形成任务接口，从而是的线程池与具体的任务无关
4 】任务队列：线程池的概念具体到实现则可能是队列，链表之类的数据结构，其中保存执行线程。 

我们实现的通用线程池框架由五个重要部分组成CThreadManage，CThreadPool，CThread，CJob，CWorkerThread，除此之外框架中还包括线程同步使用的类CThreadMutex和CCondition。 
CJob是所有的任务的基类，其提供一个接口Run，所有的任务类都必须从该类继承，同时实现Run方法。该方法中实现具体的任务逻辑。 
CThread是Linux中线程的包装，其封装了Linux线程最经常使用的属性和方法，它也是一个抽象类，是所有线程类的基类，具有一个接口Run。 
CWorkerThread是实际被调度和执行的线程类，其从CThread继承而来，实现了CThread中的Run方法。 
CThreadPool是线程池类，其负责保存线程，释放线程以及调度线程。 
CThreadManage是线程池与用户的直接接口，其屏蔽了内部的具体实现。 
CThreadMutex用于线程之间的互斥。 
CCondition则是条件变量的封装，用于线程之间的同步。

--------------------------------------------------------------------------------

事实上，线程池中容纳的线程数目并不是一成不变的，其会根据执行负载进行自动伸缩。为此在CThreadPool中设定四个变量： 
m_InitNum：处世创建时线程池中的线程的个数。 
m_MaxNum:当前线程池中所允许并发存在的线程的最大数目。 
m_AvailLow:当前线程池中所允许存在的空闲线程的最小数目，如果空闲数目低于该值，表明负载可能过重，此时有必要增加空闲线程池的数目。实现中我们总是将线程调整为m_InitNum个。 
m_AvailHigh：当前线程池中所允许的空闲的线程的最大数目，如果空闲数目高于该值，表明当前负载可能较轻，此时将删除多余的空闲线程，删除后调整数也为m_InitNum个。 
m_AvailNum：目前线程池中实际存在的线程的个数，其值介于m_AvailHigh和m_AvailLow之间。如果线程的个数始终维持在m_AvailLow和m_AvailHigh之间，则线程既不需要创建，也不需要删除，保持平衡状态。因此如何设定m_AvailLow和m_AvailHigh的值，使得线程池最大可能的保持平衡态，是线程池设计必须考虑的问题。 
线程池在接受到新的任务之后，线程池首先要检查是否有足够的空闲池可用。检查分为三个步骤： 
(1)检查当前处于忙碌状态的线程是否达到了设定的最大值m_MaxNum，如果达到了，表明目前没有空闲线程可用，而且也不能创建新的线程，因此必须等待直到有线程执行完毕返回到空闲队列中。 
(2)如果当前的空闲线程数目小于我们设定的最小的空闲数目m_AvailLow，则我们必须创建新的线程，默认情况下，创建后的线程数目应该为m_InitNum，因此创建的线程数目应该为( 当前空闲线程数与m_InitNum);但是有一种特殊情况必须考虑，就是现有的线程总数加上创建后的线程数可能超过m_MaxNum，因此我们必须对线程的创建区别对待。 Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。


端口号需要预先指定。/* 因为我们写的这个服务不是标准服务，所以用9999这个端口号。*/ 请注意，小于1024的端口号必须要有管理员权限才能绑定：

--------------------------------------------------------------------------------

Socket是什么
1、 socket套接字：
socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –> 读写write/read –> 关闭close”模式来操作。Socket就是该模式的一个实现， socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）.
说白了Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。
注意：其实socket也没有层的概念，它只是一个facade设计模式的应用，让编程变的更简单。是一个软件抽象层。在网络编程中，我们大量用的都是通过socket实现的。
2、套接字描述符
其实就是一个整数，我们最熟悉的句柄是0、1、2三个，0是标准输入，1是标准输出，2是标准错误输出。0、1、2是整数表示的，对应的FILE *结构的表示就是stdin、stdout、stderr
【句柄简介：句柄，是整个Windows编程的基础。一个句柄是指使用的一个唯一的整数值，即一个4字节(64位程序中为8字节)长的数值，来标识应用程序中的不同对象和同类对象中的不同的实例，诸如，一个窗口，按钮，图标，滚动条，输出设备，控件或者文件等。应用程序能够通过句柄访问相应的对象的信息，但是句柄不是一个指针，程序不能利用句柄来直接阅读文件中的信息。如果句柄不用在I/O文件中，它是毫无用处的。】
套接字API最初是作为UNIX操作系统的一部分而开发的，所以套接字API与系统的其他I/O设备集成在一起。特别是，当应用程序要为因特网通信而创建一个套接字（socket）时，操作系统就返回一个小整数作为描述符（descriptor）来标识这个套接字。然后，应用程序以该描述符作为传递参数，通过调用函数来完成某种操作（例如通过网络传送数据或接收输入的数据）。
在许多操作系统中，套接字描述符和其他I/O描述符是集成在一起的，所以应用程序可以对文件进行套接字I/O或I/O读/写操作。
当应用程序要创建一个套接字时，操作系统就返回一个小整数作为描述符，应用程序则使用这个描述符来引用该套接字需要I/O请求的应用程序请求操作系统打开一个文件。操作系统就创建一个文件描述符提供给应用程序访问文件。从应用程序的角度看，文件描述符是一个整数，应用程序可以用它来读写文件。下图显示，操作系统如何把文件描述符实现为一个指针数组，这些指针指向内部数据结构。2）、虽然套接字的内部数据结构包含很多字段，但是系统创建套接字后，大多数字段还没有填写。应用程序创建套接字后在该套接字可以使用之前，必须调用其他的过程来填充这些字段。
3、文件描述符和文件指针的区别：
文件描述符：在Linux系统中打开文件就会获得文件描述符，它是个很小的正整数。每个进程在PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。
文件指针：C语言中使用文件指针做为I/O的句柄。文件指针指向进程用户区中的一个被称为FILE结构的数据结构。FILE结构包括一个缓冲区和一个文件描述符。而文件描述符是文件描述符表的一个索引，因此从某种意义上说文件指
针就是句柄的句柄（在Windows系统上，文件描述符被称作文件句柄）。

--------------------------------------------------------------------------------

服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束

这些接口的实现都是内核来完成

当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。

正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。

通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。

listen()、connect()函数
如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。
listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。
connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。


accept()函数
TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。
参数sockfd参数sockfd就是上面解释中的监听套接字，这个套接字用来监听一个端口，当有一个客户与服务器连接时，它使用这个一个端口号，而此时这个端口号正与这个套接字关联。当然客户不知道套接字这些细节，它只知道一个地址和一个端口号。参数addr这是一个结果参数，它用来接受一个返回值，这返回值指定客户端的地址，当然这个地址是通过某个地址结构来描述的，用户应该知道这一个什么样的地址结构。如果对客户的地址不感兴趣，那么可以把这个值设置为NULL。参数len如同大家所认为的，它也是结果的参数，用来接受上述addr的结构的大小的，它指明addr结构所占有的字节个数。同样的，它也可以被设置为NULL。
只有accept的len参数是socklen_t*类型(其他都是socklen_t类型),他要指向一个整数,在调用被执行之前必须要将这个整数初始化为addr指向的缓冲区的大小,这样内核就知道有多少空间可用于返回socket地址了
如果accept成功返回，则服务器与客户已经正确建立连接了，此时服务器通过accept返回的套接字来完成与客户的通信。
注意：
accept默认会阻塞进程，直到有一个客户连接建立后返回，它返回的是一个新可用的套接字，这个套接字是连接套接字。
此时我们需要区分两种套接字，
监听套接字: 监听套接字正如accept的参数sockfd，它是监听套接字，在调用listen函数之后，是服务器开始调用socket()函数生成的，称为监听socket描述字(监听套接字)
连接套接字：一个套接字会从主动连接的套接字变身为一个监听套接字；而accept函数返回的是已连接socket描述字(一个连接套接字)，它代表着一个网络已经存在的点点连接。
一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。
自然要问的是：为什么要有两种套接字？原因很简单，如果使用一个描述字的话，那么它的功能太多，使得使用很不直观，同时在内核确实产生了一个这样的新的描述字。
连接套接字socketfd_new 并没有占用新的端口与客户端通信，依然使用的是与监听套接字socketfd一样的端口号


--------------------------------------------------------------------------------

--------------------------------------------------------------------------------

socket结构体不仅仅记录了本地的IP和端口号，还记录了目的IP和端口。


     问题二：connect函数究竟做了些什么操作？
     在TCP客户端，首先调用一个socket()函数，得到一个socket描述符socketfd，然后通过connect函数对服务器进行连接，连接成功后，就可以利用这个socketfd描述符使用send/recv函数收发数据了。
    关于connect函数和send函数的原型如下：
int connect( int sockfd, const struct sockaddr* server_addr, socklen_t addrlen)  

int send( int sockfd, const void *msg,int len／／／／／,int flags); 
    那么，现在的困惑是，为什么send函数仅仅传入sockfd就可以知道服务器的ip和端口号？
    sockfd 描述符所描述的socket对象不仅包含了本地IP和端口，同时也包含了服务器的IP和端口，这样，才能使得send函数只需要传入sockfd 即可知道该把数据发向什么地方。而代码中，目的IP和端口只是在connect函数中出现过，因此，肯定是connect函数在成功建立连接后，将目的IP和端口写入了sockfd 描述符所描述的socket对象中。



问题三： accept函数产生的socket有没有占用新的端口？
首先，回顾一下accept函数，原型如下：
/* 参数：sockfd 监听套接字，即服务器端创建的用于listen的socket描述符。  
 * 参数：addr  这是一个结果参数，它用来接受一个返回值，这返回值指定客户端的地址  
 * 参数：len 描述 addr 的长度  
 */ 
int accept(int sockfd, struct sockaddr* addr, socklen_t* len)  
 
    accept函数主要用于服务器端，一般位于listen函数之后，默认会阻塞进程，直到有一个客户请求连接，建立好连接后，它返回的一个新的套接字 socketfd_new ，此后，服务器端即可使用这个新的套接字socketfd_new与该客户端进行通信，而sockfd 则继续用于监听其他客户端的连接请求。
    至此，我的困惑产生了，这个新的套接字 socketfd_new 与监听套接字sockfd 是什么关系？它所代表的socket对象包含了哪些信息？socketfd_new 是否占用了新的端口与客户端通信？
    先简单分析一番，由于网站的服务器也是一种TCP服务器，使用的是80端口，并不会因客户端的连接而产生新的端口给客户端服务，该客户端依然是向服务器端的80端口发送数据，其他客户端依然向80端口申请连接。因此，可以判断，socketfd_new 并没有占用新的端口与客户端通信，依然使用的是与监听套接字socketfd_new一样的端口号。
    那这么说，难道一个端口可以被两个socket对象绑定？当客户端发送数据过来的时候，究竟是与哪一个socket对象通信呢？
 
    我是这么理解的（欢迎拍砖）。
    首先，一个端口肯定只能绑定一个socket。我认为，服务器端的端口在bind的时候已经绑定到了监听套接字socetfd所描述的对象上，accept函数新创建的socket对象其实并没有进行端口的占有，而是复制了socetfd的本地IP和端口号，并且记录了连接过来的客户端的IP和端口号。
    那么，当客户端发送数据过来的时候，究竟是与哪一个socket对象通信呢？
    客户端发送过来的数据可以分为2种，一种是连接请求，一种是已经建立好连接后的数据传输。
    由于TCP/IP协议栈是维护着一个接收和发送缓冲区的。在接收到来自客户端的数据包后，服务器端的TCP/IP协议栈应该会做如下处理：如果收到的是请求连接的数据包，则传给监听着连接请求端口的socetfd套接字，进行accept处理；如果是已经建立过连接后的客户端数据包，则将数据放入接收缓冲区。这样，当服务器端需要读取指定客户端的数据时，则可以利用socketfd_new 套接字通过recv或者read函数到缓冲区里面去取指定的数据（因为socketfd_new代表的socket对象记录了客户端IP和端口，因此可以鉴别）。原型：
#include<pthread.h>
void pthread_exit(void *rval_ptr);
参数是个空类型的指针
这个函数的功能就是使一个线程正常退出，终止线程，并返回一个指向某个对象的指针，该返回值可以通过pthread_join函数的第二个参数得到。
因为我们知道线程它是依赖进程存在的，如果在线程中使用
exit()函数退出，那么整个的进程将会退出，那么如果此时你还有一些其它需要做的事情没有完成呢，这并不是我们所希望的。
这个参数保存的是线程退出以后返回的值。当然这个参数传递的数值可以不止一个，比如 该我们想传递好几个参数怎么办呢，很快我们就能够想到我们所学过的结构体呀之类的，此时问题就来了，需要注意的问题是：这个结构所使用的内存在调用者完成调用以后必须仍然是有效的，否则就会出现非法访问内存。例如在线程栈上分配了该结构，那么其他的线程在是用这个结构时内存内容可能已经改变了。又如，线程在自己的栈上分配了一个结构然后把指向这个结构的指针传给pthread_exit（），那么当调用pthread_join的线程试图使用该结构时，这个栈有可能已经被撤销，这块内存也已令做他用。声明有紧急数据时（ MSG_OOB )，会将其加入到发送缓冲区中，紧急指针指向最后一个带外数据的下一位，然后前一个被当做紧急数据，其他的都被当成普通数据，然后接收端接收后，将紧急数据读入一块特殊的缓存（带外缓存，只有１字节）
例如：
发送缓冲区已经有：１２３
然后现在声明：ａｂｃ为紧急数据，那么将ａｂｃ加入发送缓冲区：１２３ａｂｃ
ｃ的下一字节是紧急指针，只有c被当做紧急数据
接收端接收１２３ａｂｃ，ｃ被存入带外缓存，等待特定读取：recv(... , ... , .., MSG_OOB);>exit和_exit函数都是用来终止进程的。
当程序执行到exit或_exit时，系统无条件的停止剩下所有操作，清除包括PCB在内的各种数据结构，并终止本进程的运行。
2>exit在头文件stdlib.h中声明，而_exit()声明在头文件unistd.h中声明。 exit中的参数exit_code为０代表进程正常终止，若为其他值表示程序执行过程中有错误发生。
3>exit()和_exit()的区别：

a._exit()执行后立即返回给内核，而exit()要先执行一些清除操作，然后将控制权交给内核。
b. 调用_exit函数时，其会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数，但不会刷新流(stdin, stdout, stderr  ...).   exit函数是在_exit函数之上的一个封装，其会调用_exit，并在调用之前先刷新流。
Ｔiger-John说明：
exit()函数与_exit()函数最大区别就在于exit()函数在调用exit系统之前要检查文件的打开情况，把文件缓冲区的内容写回文件。由于Linux的标准函数库中，有一种被称作“缓冲I/O”的操作，其特征就是对应每一个打开的文件，在内存中都有一片缓冲区。每次读文件时，会连续的读出若干条记录，这样在下次读文件时就可以直接从内存的缓冲区读取；同样，每次写文件的时候也仅仅是写入内存的缓冲区，等满足了一定的条件（如达到了一定数量或遇到特定字符等），再将缓冲区中的内容一次性写入文件。这种技术大大增加了文件读写的速度，但也给编程代来了一点儿麻烦。比如有一些数据，认为已经写入了文件，实际上因为没有满足特定的条件，它们还只是保存在缓冲区内，这时用_exit()函数直接将进程关闭，缓冲区的数据就会丢失。因此，要想保证数据的完整性，就一定要使用exit()函数。


exit(0)表示程序正常, exit(1)和exit(-1)表示程序异常退出，exit(2)表示系统找不到指定的文件

pthread_exit()函数
原型：
#include<pthread.h>
void pthread_exit(void *rval_ptr);
参数是个空类型的指针
这个函数的功能就是使一个线程正常退出，终止线程，并返回一个指向某个对象的指针，该返回值可以通过pthread_join函数的第二个参数得到。


>
因为我们知道线程它是依赖进程存在的，如果在线程中使用
exit()函数退出，那么整个的进程将会退出，那么如果此时你还有一些其它需要做的事情没有完成呢，这并不是我们所希望的。
这个参数保存的是线程退出以后返回的值。当然这个参数传递的数值可以不止一个，比如 该我们想传递好几个参数怎么办呢，很快我们就能够想到我们所学过的结构体呀之类的，此时问题就来了，需要注意的问题是：这个结构所使用的内存在调用者完成调用以后必须仍然是有效的，否则就会出现非法访问内存。例如在线程栈上分配了该结构，那么其他的线程在是用这个结构时内存内容可能已经改变了。又如，线程在自己的栈上分配了一个结构然后把指向这个结构的指针传给pthread_exit（），那么当调用pthread_join的线程试图使用该结构时，这个栈有可能已经被撤销，这块内存也已令做他用。
